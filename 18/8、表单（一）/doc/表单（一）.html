<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="691"/>

<div>
<span><div><ul><li><span style="font-size: 10pt;">什么是表单:</span></li><ul><li><span style="font-size: 10pt;">表单是HTML中用于提交数据给服务器的一个标签,所有的表单元素(input/textarea/button...)都要放在form标签当中.然后有以下参数:</span></li></ul></ul></div><div><ul><ul><li><font style="font-size: 10pt;">`form`的`method`参数用于设置表单的提交方式,默认使用`POST`.</font></li><li><font style="font-size: 10pt;">`action`用于设置表单的提交url,如果不写或者保持空字符串,那么将使用当前的URL.</font></li><li><span style="font-size: 13.3333px;">你的action尽量指定一个url，因为这块会有浏览器兼容问题，有的浏览器填空是不能获取到对应的action</span></li></ul><li>一个会话的流程</li></ul><div><img src="表单（一）_files/Image.png" type="image/png" data-filename="Image.png"/></div></div><div><ul><li><span style="font-size: 10pt;"> GET和POST:</span></li><ul><li><span style="font-size: 10pt;"> `GET`:GET如其名，是从服务器获取数据，不会更改服务器的状态和数据，在URL中携带参数发送给服务器。</span></li><li><span style="font-size: 10pt;">POST则是将一定量的数据发送给服务器，一般会更改服务器的数据。</span></li><li><span style="font-size: 10pt;">POST方法的参数不能在URL当中看到,他是通过body参数传递给服务器的,所以相对GET方法直接能在URL当中看到传递的参数,显得更加安全一些.当然,也不能简单的判定POST方法比GET方法更安全,要使网站保持安全,需要做更多的安全处理.</span></li></ul></ul></div><div><br/></div><div><ul><li><span style="font-size: 10pt;">HttpRequest:</span></li><ul><li><span style="font-size: 10pt;">request.scheme：网络请求的协议，一般是http和https</span></li><li><span style="font-size: 10pt;">request.body：http请求中传递的原始数据，是一个byte类型的string，如果要处理form表单上传上来的数据，应该使用request.POST，这个处理得比较好。</span></li><li><span style="font-size: 10pt;">request.path：当前请求的URL路径，但是不包括scheme和域名，比如有</span><a href="http://www.myblog.com/blog/1" style="font-size: 10pt; color: rgb(0, 0, 0);">http://www.myblog.com/blog/1</a><span style="font-size: 10pt;">。那么返回的将是/blog/1。会去除掉http和</span><a href="http://www.myblog.com/" style="font-size: 10pt; color: rgb(0, 0, 0);">www.myblog.com</a></li><li><span style="font-size: 10pt;">request.method：当前这个请求访问方法，一般为GET和POST，例如可以通过以下方式进行判断：</span></li><ul><li>request.GET：一个QueryDict的类字典类型的对象，可以通过访问字典的方式进行访问里面的值，里面的值是通过GET请求传递进来的参数。</li><li><span style="font-size: 10pt;">request.POST：同request.GET，但是是保存了通过POST请求传递上来的参数。注意，这个POST里面不包含上传的文件信息。</span></li><li><span style="font-size: 10pt;">request.FILES </span><span style="font-size: 10pt;">: 如果要访问上传的文件，请使用request.FILES。</span></li></ul><li>request.COOKIES：一个字典类型，包含了所有的cookie信息，key和value都是字符串。</li><li>request.META：存储所有请求的头部信息。</li><li>request.session：返回一个QueryDict的类字典类型的集合，这个属性要有效，必须添加SessionMiddleware这个中间件。</li><li>request.is_secure()：如果是HTTPS的，那么返回True，否则返回False</li><li>request.is_ajax()：这个请求是否是通过XMLHttpRequest进行访问的。</li><ul><li>他的实现原理就是去request.META中查找HTTP_X_REQUESTED_WITH，如果是XMLHttpRequest，那么将返回True，否则返回False。**一般在第三方库如jQuery中使用ajax方法都设置了这个值，如果自己手动写XMLHttpRequest，那么需要自己添加这个header，is_ajax这个方法才能生效。</li></ul></ul></ul></div><div><br/></div><div><ul><li><span style="font-size: 10pt;"> HttpResponse对象:</span></li><ul><li><span style="font-size: 10pt;">HttpResponse.__init__(content=’’,content_type=None,status=200,reason=None,charset=None)构造方法：</span></li><li><span style="font-size: 10pt;">content：代表要发送给客户端的内容。</span></li><li><span style="font-size: 10pt;">content_type：代表发送给客户端的内容类型，默认是“text/html;charset=utf-8”。</span></li><li><span style="font-size: 10pt;">charset：响应体的编码，如果没有指定，则会使用content_type中设置的charset。</span></li><li><span style="font-size: 10pt;">set_cookie(key,value=’’,max_age=None,expires=None,path=’/’,domain=None,secure=None,httponly=False)</span></li><ul><li><span style="font-size: 10pt;">key：cookie的key。</span></li><li><span style="font-size: 10pt;">value：cookie的value。</span></li><li><span style="font-size: 10pt;">max_age：cookie最大的过期时间。</span></li><li><span style="font-size: 10pt;">expires：cookie的过期时间和日期。</span></li><li><span style="font-size: 10pt;">path：针对哪个目录下有效果。</span></li><li><span style="font-size: 10pt;">domain：域名，如果你想跨域使用cookie，必须设置这个值，比如domain=”.</span><a href="http://lawrence.com/" style="font-size: 10pt; color: rgb(0, 0, 0);">lawrence.com</a><span style="font-size: 10pt;">”，那么</span><a href="http://www.lawrence.com/" style="font-size: 10pt; color: rgb(0, 0, 0);">www.lawrence.com</a><span style="font-size: 10pt;">和</span><a href="http://blogs.lawrence.com/" style="font-size: 10pt; color: rgb(0, 0, 0);">blogs.lawrence.com</a><span style="font-size: 10pt;">和</span><a href="http://calendars.lawrence.com/" style="font-size: 10pt; color: rgb(0, 0, 0);">calendars.lawrence.com</a><span style="font-size: 10pt;">都可以访问到这个cookie。</span></li><li><span style="font-size: 10pt;">httponly：如果设置为True，客户端的js代码将不能访问到cookie。</span></li></ul><li>delete_cookie(key,path=’/’,domain=None)：删除cookie。</li><li>response子类</li><ul><li>BadHeaderError</li><li>FileResponse</li><li>Http404</li><li>HttpResponse</li><li>HttpResponseBadRequest</li><li>HttpResponseForbidden</li><li>HttpResponseGone,</li><li>HttpResponseNotAllowed</li><li>HttpResponseNotFound</li><li>HttpResponseNotModified,</li><li>HttpResponsePermanentRedirect</li><li>HttpResponseRedirect,</li><li>HttpResponseServerError</li><li>JsonResponse</li><li>StreamingHttpResponse</li></ul></ul><li>cookie</li><ul><li>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。</li><li>而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。</li><li>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</li></ul><li>session</li><ul><li>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</li><li>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</li></ul><li>使用session与cookie完成登录页面</li><ul><li>建立一个用户Model</li></ul><li>通过request.POST获取数据</li><li>通过session+cookie保存登录状态</li><li>crsf_token: 防跨域html标签</li></ul></div><div><br/></div><div>作业：完成博客页面的登录</div></span>
</div></body></html> 